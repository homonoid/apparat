root: node (";" node)* [";"]

?node: stmt
     | expr

?stmt: decl
     | infix

decl: ID "=" expr
infix: ID ID ID "=" expr

?expr: conj
     | conj "=>" node "else" node -> condition

?conj: equ
     | equ "and" expr -> conj 
     | equ "or" expr  -> disj

?equ: compare
    | compare "is" equ
    | compare "is" "not" equ

?compare: sum
        | sum "<" compare  -> lt
        | sum ">" compare  -> gt
        | sum "<=" compare -> lte
        | sum ">=" compare -> gte

?sum: product
    | product "+" sum -> add
    | product "-" sum -> sub

?product: molecule
        | molecule "*" product   -> mul
        | molecule "/" product   -> div
        | molecule "mod" product -> mod

?molecule: atom
         | "(" (ID | INFIX) ")" atom -> distribute
         | atom "^" molecule -> pow

?atom: list
     | num
     | text
     | ID -> req
     | accessor
     | call
     | field
     | range
     | "-" atom -> neg
     | "+" atom -> pos
     | "(" expr ")"
     | "{" (node (";" node)* [";"])? "}" -> block
     | "|" ID ("," ID)* "|" expr -> lambda
     
list: "[" atom* "]"

?num: DECIMAL -> decimal
    | FRACT   -> fractional
    | BIN     -> binary
    | OCT     -> octal
    | HEX     -> hexadecimal

text: "\"" (TCHAR | "{" expr "}")* "\""

range: atom "to" atom

accessor: atom "[" atom "]"

call: atom "(" [expr ("," expr)*] ")"

field: atom ("." ID)+

// Lexer

ID: /[a-zA-Z_][a-zA-Z0-9_]+|[a-zA-Z]/
DECIMAL: /[1-9][0-9]*|0/
FRACT: /[0-9]+\.[0-9]+(e\-?[0-9]+)?/
BIN.2: /0b[01]+/
HEX.2: /0x[0-9A-fa-f]+/
OCT.2: /0o[0-7]+/
TCHAR: /[^\n"\\\{]|\\[ntvr]/
INFIX.2: "+" | "-" | "*" | "/" | "mod" | "and" | "or" 
     |  "is" "not" | "is" | "<=" | ">=" | "<" | ">"


%import common.WS
%ignore WS
